- #concept #architecture #Springboot
- ### I. 이벤트 생산자와 소비자
	- 생산자: 이벤트 감지 및 알림 전송
		- 주로 브로커가 운영하는 채널에 메시지를 발행하여 알림을 전송
	- |
	- 브로커: 생산자가 발행한 메시지를 수집하고 소비자에게 라우팅
		- 생산자와 소비자의 결합을 최소화하기 위한 요소
	- |
	- 소비자: 이벤트 발생 알림을 받는 요소
	- 이벤트의 생산자와 소비자는 비동기적으로 상호작용하며, 서로에 대해 독립적으로 실행된다. 그 결과, 각 요소는 느슨한 결합을 유지하며, 각 요소간 상호작용은 브로커를 통해 이루어진다.
-
- ### II. 이벤트 중심 아키텍처 모델
	- 발행자/구독자 (pub/sub) 모델
	  logseq.order-list-type:: number
		- 생산자: 이벤트를 발행
		- 소비자: 구독한 생산자의 이벤트만 수신
		- 브로커: 발행된 이벤트를 한정된 소비자에게 전송
		- -> 이벤트는 수신후 재생산되지 않음 (과거의 이벤트는 소비 후 사라짐)
		- (ex) RabbitMQ
	- 이벤트 스트리밍 모델
	  logseq.order-list-type:: number
		- 생산자: 발생한 이벤트를 로그에 저장
		- 소비자: 스트림의 특정 부분을 읽어 이벤트 확인
		- -> 이벤트 기록이 소실되지 않음. 실시간 데이터 파이프라인 구축 가능.
		- (ex) Apache Kafka
-
- ### III. pub/sub 모델에서 메시징 시스템
	- 메시징 시스템의 요소
	  logseq.order-list-type:: number
		- 브로커
		- 프로토콜
	- AdvancedMessageQueueingProtocol
	  logseq.order-list-type:: number
		- AMQP의 메세지는 키-값 속성과 이진페이로드로 구성된 데이터 구조
		- (ex) RabbitMQ
		- Spring AMQP 프로젝트 https://spring.io/projects/spring-amqp
		- 생산자: 메시지의 발행자
		- 소비자: 메시지의 구독자
		- 브로커: 생산자로부터 메시지를 받아 소비자에게 라우팅 (미들웨어) -> AMQP 행위자
		- ![AMQP & RabbitMQ](https://blog.kakaocdn.net/dna/7gbEI/btst6NZIH86/AAAAAAAAAAAAAAAAAAAAAE5DjZYbBO7QXAOYsYTmCgRl0UIgX69kGXSi0isltkwg/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=xSVajX%2FdQ%2FbTME9Gay1pTVOcTHQ%3D)
-
- ### IV. Springboot 환경에서 AMQP 적용
	- 대상 바인딩
	  logseq.order-list-type:: number
		- 어플리케이션과 브로커를 연결해주는 추상화
		- 스프링 함수와 AMQP의 브로커를 연결하는 과정
		- 입력바인딩: <functionName> + -in- + <index>
			- destination: 브로커 내에서의 실제 이름
			- group: 소비자 그룹
		- 출력바인딩: <functionName> + -out- + <index>
			- destination
		-
-
- ### 추가 학습 내용
	- https://martinfowler.com/eaaDev/EventNarrative.html / https://martinfowler.com/eaaDev/DomainEvent.html / https://martinfowler.com/articles/201701-event-driven.html
	  logseq.order-list-type:: number
-
- ### 출처
	- 클라우드 네이티브 스프링 인 액션 (토마스 비탈레)
-
- ### 수정 내역
	- [[Jul 23rd, 2025]] 최초 발행
-